//Question no. 234 on leetcode
//This is the solution to the approach I came up with first.
//We first find out the length, middle element and push half of the Linked List in a stack
//Then we compare the elements pushed into the stack with the second half of the Linked List, if any element is not equal, we return false.

class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr) return true;
        
        ListNode * fast = head->next;
        ListNode * slow = head;
        int size = 1;
        stack<ListNode*> stk;
        
        while(fast != nullptr){
            if(fast->next == nullptr){
                size+=1;
                stk.push(slow);
                slow=slow->next;
                fast=fast->next;
                continue;
            }
            //if(fast->next->next != nullptr){
            size+=2;
            stk.push(slow);
            slow = slow->next;
            fast = fast->next->next;
        }
        
        if(size%2==0){
            while(slow != nullptr){
                if(slow->val != stk.top()->val){
                    return false;
                }
                else{
                    stk.pop();
                    slow=slow->next;
                }
            }
            //return true;
        }
        else{
            slow=slow->next;
            while(slow != nullptr){
                if(slow->val != stk.top()->val){
                    return false;
                }
                else{
                    stk.pop();
                    slow=slow->next;
                }
            }
            //return true;
        }
        return true;
    }
};

//Above Solution uses a stack which increases the Space Complexity of the solution, so here is another more optimised approach to the question:
//In the approach, we find the middle element like we did above, but in doing so, we flip the first half of the Linked List. The previous to slow pointer will point to the
//beginning of the reversed first half LL we have now created. Now we just compare the 2 new Linked Lists and we're done.
